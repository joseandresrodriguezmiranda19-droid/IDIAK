<!DOCTYPE html>

<html lang="es">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Reporte PDF — Réplica de página 1</title>
<style>
  :root {
    --green:#00a651;
    --red:#ff0000;
    --blue:#0033ff;
    --gray:#666;
    --black:#000;
    --line:#111;
  }
  html,body{margin:0;padding:0;background:#fff;font-family: Arial, Helvetica, sans-serif;color:#000;}
  .page{width: 1100px; margin: 10px auto 20px auto; padding: 10px 20px 20px 20px; box-sizing:border-box;}
  .topbar{display:flex; align-items:flex-end; justify-content:space-between;}
  .idiak{font-weight:800; font-size:46px; color:var(--green); letter-spacing:1px;}
  .pdfreport{font-weight:700; font-size:34px; color:#777;}
  .rule{height:2px;background:#1a1a1a;margin:8px 0 16px 0;}
  .failbox{width:260px;margin: 0 auto 6px auto;border:4px solid var(--red); color:var(--red); font-weight:800;
            text-align:center; font-size:40px; padding: 14px 0;}
  .tz{text-align:center; font-size:16px; margin: 6px 0 10px 0;}
  .tz b{font-weight:700;}
  .row{display:flex; gap:26px; align-items:flex-start; justify-content:center;}
  table{border-collapse:collapse; font-size:13px;}
  .alarmTable{min-width:600px;}
  .alarmTable th,.alarmTable td{border:1px solid #444; padding:4px 8px; vertical-align:middle;}
  .alarmTable th{text-align:left; font-weight:700;}
  .alarmTable .hdr{background:#fff; font-weight:700;}
  .r{color:var(--red); font-weight:700;}
  .b{color:var(--blue); font-weight:700;}
  .deviceBox{width:320px; border:1px solid #444; padding:10px 10px 8px 10px;}
  .deviceTitle{text-align:center; font-weight:800; font-size:16px; margin-bottom:6px;}
  .deviceGrid{display:grid; grid-template-columns: 1fr; gap:4px; font-size:13px;}
  .summaryTitle{font-weight:800; font-size:18px; margin: 18px 0 6px 0;}
  .summaryBox{border:1px solid #444; padding:10px; font-size:13px;}
  .summaryFlex{display:flex; justify-content:space-between; gap:20px;}
  .summaryCol{flex:1;}
  .summaryLine{margin: 6px 0; white-space:nowrap;}
  .chartLegendRow{display:flex; justify-content:space-between; font-size:12px; margin-top:8px; align-items:center; padding:0 10px; box-sizing:border-box;}
  .legendLeft,.legendRight{display:flex; align-items:center; gap:10px; color:#000;}
  .swatch{width:36px; height:0; border-top:2px solid #000;}
  .swBlue{border-top-color: var(--blue);}
  .swGreen{border-top-color: #00cc00;}
  .swRedDash{border-top:2px dashed var(--red); width:40px;}
  .swBlueDash{border-top:2px dashed var(--blue); width:40px;}
  .swRed{border-top:2px solid var(--red); width:40px;}
  .swBlueSolid{border-top:2px solid var(--blue); width:40px;}
  .chartWrap{margin-top:6px;}
  canvas{display:block; border:1px solid #444;}
  .sectionLabel{font-weight:800; margin-top:16px;}
  .hr{height:2px;background:#1a1a1a;margin:6px 0 10px 0; opacity:0.7;}
  .marked{color:#00cc00; font-size:13px; margin: 0 0 4px 0;}
  .foot{display:flex; justify-content:flex-end; gap:40px; margin-top: 36px; color:#777; font-weight:700;}

  /* Controls */
  .controls{
    width:1100px;
    margin:10px auto 0 auto;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    padding:10px 20px;
    border:1px solid #000;
    background:#fff;
    box-sizing:border-box;
  }
  .controls-left{display:flex;align-items:center;gap:10px;}
  .controls-right{display:flex;align-items:center;gap:10px;}
  .filebtn{display:inline-flex;align-items:center;gap:8px;cursor:pointer;}
  .filebtn input{display:none;}
  .filebtn span, #btnExport{
    font-size:14px;
    padding:8px 12px;
    border:1px solid #000;
    background:#fff;
    cursor:pointer;
    user-select:none;
  }
  #btnExport:active, .filebtn span:active{transform:translateY(1px);}
  .hint{font-size:12px;color:#111;}

  .filter{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end;}
  .filter input{font-size:12px; padding:6px 8px; border:1px solid #000; background:#fff;}
  .filter select{font-size:12px; padding:6px 8px; border:1px solid #000; background:#fff;}
  .filter button{font-size:13px; padding:7px 10px; border:1px solid #000; background:#fff; cursor:pointer;}
  .filter button:active{transform:translateY(1px);}

  .toast{
    position:fixed; left:50%; top:16px; transform:translateX(-50%);
    background:#fff; border:1px solid #000; padding:8px 12px; font-size:13px;
    z-index:9999; box-shadow:0 2px 8px rgba(0,0,0,.15);
  }

  /* Printing */
  @page { size: A4 landscape; margin: 8mm; }
  @media print{
    @page { size: A4 landscape; margin: 8mm; }
    body{background:#fff;}
    .controls{display:none !important;}
    .page{width:auto !important; margin:0 !important; padding:0 !important;}

    /* Force exactly 2 pages:
       - Page 1: report blocks (topbar + alarm limits + device config + summary)
       - Page 2: legend + chart
    */
    .printPage1{ break-after: auto; page-break-after: auto; }
    .printPage2{ break-before: page; page-break-before: always; padding-top: 3mm; }

    /* Prevent awkward splits */
    .row, .summaryBox, .deviceBox, .alarmTable { break-inside: avoid; page-break-inside: avoid; }

    /* Chart page spacing (keep legend away from edges, but stay on same page) */
    #chartSection{ margin-top: 0 !important; padding: 0 !important; }
    #chartSection .chartLegendRow{
      margin: 0 0 2mm 0 !important;
      padding: 0 7mm !important;
      font-size: 11px !important;
    }
    #chartSection .legendLeft, #chartSection .legendRight{ gap: 10px !important; }
    #chartSection .chartWrap{ margin-top: 0 !important; padding: 0 7mm 0 7mm !important; box-sizing:border-box; }

    /* Hide footer in print to avoid creating an extra page */
    .foot{ display:none !important; }

    canvas{ width: 100% !important; height: 170mm !important; border: 1px solid #333 !important; }
  }

</style>
</head>
<body>
<div aria-label="Controles del dashboard" class="controls">
<div class="controls-left">
<label class="filebtn">
<input accept=".csv,text/csv" id="csvInput" type="file"/>
<span>Subir CSV</span>
</label>
<button id="btnExport" type="button">Exportar PDF</button>
</div>
<div class="controls-right">
<span class="hint" id="csvHint">CSV actual: (ninguno)</span>
<div class="filter">
  <span class="hint" style="font-weight:700;">Periodo:</span>
  <label class="hint">Encabezados 
    <select id="tickCount">
      <option value="8" selected>8</option>
      <option value="16">16</option>
    </select>
  </label>
  <label class="hint">Desde <input id="dtStart" type="datetime-local"></label>
  <label class="hint">Hasta <input id="dtEnd" type="datetime-local"></label>
  <button id="btnApply" type="button">Aplicar</button>
  <button id="btnReset" type="button">Todo</button>
  <span class="hint" id="filterInfo">(0 puntos)</span>
</div>
</div>
</div>
<div class="page">
<div class="printPage printPage1">
<div class="topbar">
<div class="idiak">IDIAK</div>
<div class="pdfreport">Reporte PDF</div>
</div>
<div class="rule"></div>
<div class="tz" id="tzLine">Zona horaria: (<b>GMT-06:00</b>) dd/mm/yy</div>
<div class="row">
<table class="alarmTable">
<tbody id="alarmBody"><tr class="hdr">
<th>Límites de alarma</th>
<th>Tiempo total</th>
<th>Primera alarma</th>
</tr></tbody></table>
<div class="deviceBox">
<div class="deviceTitle">CONFIGURACIÓN DEL DISPOSITIVO</div>
<div class="deviceGrid">
<div>Numero de Modelo <span id="tripNumber">—</span></div>
<div>Retraso de inicio:0min</div>
<div>Límites de alarma altos:22.00°C  70.00%</div>
<div>Límites de alarma bajos:0.00°C  60.00%</div>
<div>Alarm Delay:10min</div>
<div>Alarm type:Cumulative</div>
<div>Intervalo de registro/Duración: <span id="logInterval">—</span></div>
</div>
</div>
</div>
<div class="summaryTitle">RESUMEN</div>
<div class="summaryBox">
<div class="summaryFlex">
<div class="summaryCol">
<div class="summaryLine"><span class="r">Temperatura máxima:</span>: <span id="maxTempLine">—</span></div>
<div class="summaryLine"><span class="b">Temperatura mínima:</span>: <span id="minTempLine">—</span></div>
<div class="summaryLine">Temperatura promedio: <span id="avgTempLine">—</span></div>
<div class="summaryLine">Temperatura cinética media: <span id="mktLine">—</span></div>
<div class="summaryLine">Puntos de datos: <span id="dataPointsLine">0</span></div>
</div>
<div class="summaryCol">
<div class="summaryLine"><span class="r">Humedad máxima:</span>: <span id="maxRhLine">—</span></div>
<div class="summaryLine"><span class="b">Humedad mínima:</span>: <span id="minRhLine">—</span></div>
<div class="summaryLine">Humedad promedio: <span id="avgRhLine">—</span></div>
</div>
<div class="summaryCol" style="max-width:260px;">
<div class="summaryLine">Hora de inicio:&nbsp;&nbsp;<span id="sumStart">—</span></div>
<div class="summaryLine">Hora de fin:&nbsp;&nbsp;<span id="sumStop">—</span></div>
<div class="summaryLine">Duracion del Registro&nbsp;&nbsp;<span id="sumTripLen">—</span></div>
<div class="summaryLine">Estado:  Conexión USB</div>
</div>
</div>
</div>
</div>
<div class="printPage printPage2">
<div id="chartSection" class="chartSection">
<div class="chartLegendRow">
<div class="legendLeft">
<div>[°C]</div>
<div class="swatch swBlue"></div><div>datos</div>
<div class="swRedDash"></div><div>Alarma</div>
<div class="swBlueDash"></div><div>Alarma</div>
</div>
<div class="legendRight">
<div>[%RH]</div>
<div class="swatch swGreen"></div><div>datos</div>
<div class="swRed"></div><div>Alarma</div>
<div class="swBlueSolid"></div><div>Alarma</div>
</div>
</div>
<div class="chartWrap">
<canvas aria-label="Gráfico de temperatura y humedad" height="560" id="chart" width="980"></canvas>
</div>
</div>
<div class="foot">
<div>(Ver 3.0.13)</div>
<div>1/5</div>
</div>
</div>
</div>
<script>
  let DATA = [];

  let RAW_DATA = [];
  let CURRENT_META = { deviceId: '', timeZone: '(GMT-06:00)dd/mm/yy' };

  const dtStart = document.getElementById('dtStart');
  const dtEnd   = document.getElementById('dtEnd');
  const tickSel = document.getElementById('tickCount');
  let TICK_COUNT = 8;
  if(tickSel){
    TICK_COUNT = parseInt(tickSel.value,10) || 8;
    tickSel.addEventListener('change', () => {
      TICK_COUNT = parseInt(tickSel.value,10) || 8;
      draw();
    });
  }
  const btnApply = document.getElementById('btnApply');
  const btnReset = document.getElementById('btnReset');
  const filterInfo = document.getElementById('filterInfo');

  function toInputValue(ms){
    const d = new Date(ms);
    const pad = (n)=> String(n).padStart(2,'0');
    const yyyy = d.getFullYear();
    const mm = pad(d.getMonth()+1);
    const dd = pad(d.getDate());
    const hh = pad(d.getHours());
    const mi = pad(d.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
  }


function formatTime(d){
  const pad = n => String(n).padStart(2,'0');
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function formatDate(d){
  const pad = n => String(n).padStart(2,'0');
  const yy = String(d.getFullYear()).slice(-2);
  return `${pad(d.getDate())}/${pad(d.getMonth()+1)}/${yy}`;
}
function buildTicksFromData(arr, count=8){
  if(!arr || arr.length===0) return [];
  const xMin = arr[0].t;
  const xMax = arr[arr.length-1].t;
  if(!isFinite(xMin) || !isFinite(xMax) || xMax<=xMin){
    const d = new Date(xMin);
    return [{t:xMin, label_time: formatTime(d), label_date: formatDate(d)}];
  }
  const ticks = [];
  const n = Math.max(2, count|0);
  for(let i=0;i<n;i++){
    const t = xMin + (xMax - xMin) * (i/(n-1));
    const d = new Date(t);
    ticks.push({t, label_time: formatTime(d), label_date: formatDate(d)});
  }
  return ticks;
}

  function clampFilterInputsToData(){
    if(!RAW_DATA.length || !dtStart || !dtEnd) return;
    const minT = RAW_DATA[0].t;
    const maxT = RAW_DATA[RAW_DATA.length-1].t;
    if(!dtStart.value) dtStart.value = toInputValue(minT);
    if(!dtEnd.value) dtEnd.value = toInputValue(maxT);
  }

  function parseDTStart(val){
    if(!val) return -Infinity;
    const t = new Date(val).getTime();
    return isFinite(t) ? t : NaN;
  }
  function parseDTEnd(val){
    if(!val) return Infinity;
    let t = new Date(val).getTime();
    if(!isFinite(t)) return NaN;
    // datetime-local commonly has minute precision (YYYY-MM-DDTHH:MM). Treat "Hasta" as inclusive.
    if(val.length === 16){
      t += 60*1000 - 1; // include whole minute
    } else if(val.length === 19){
      t += 1000 - 1; // include whole second if seconds are present
    }
    return t;
  }

  function applyFilter(){
    if(!dtStart || !dtEnd) return;
    if(!RAW_DATA || !RAW_DATA.length){
      showToast('Primero cargá un CSV.');
      return;
    }
    const start = parseDTStart(dtStart.value);
    const end   = parseDTEnd(dtEnd.value);

    if(!(isFinite(start) && isFinite(end)) || start > end){
      showToast('Periodo inválido. Revisá "Desde" y "Hasta".');
      return;
    }

    const filtered = RAW_DATA.filter(p => p.t >= start && p.t <= end);
    if(!filtered.length){
      showToast('No hay datos en ese periodo.');
      return;
    }
    DATA = filtered;

    const alarmPoint = findFirstAlarmPoint(DATA);
    const mid = DATA[Math.floor(DATA.length/2)];
    window.MARKED = alarmPoint || { t: mid.t, temp: mid.temp, rh: mid.rh };

    if(filterInfo) filterInfo.textContent = `(${DATA.length} puntos)`;
    updateReport(CURRENT_META, DATA);
    setCanvasSize();
    draw();
  }

  function resetFilter(){
    if(!RAW_DATA || !RAW_DATA.length){
      showToast('Primero cargá un CSV.');
      return;
    }
    DATA = RAW_DATA.slice();

    const alarmPoint = findFirstAlarmPoint(DATA);
    const mid = DATA[Math.floor(DATA.length/2)];
    window.MARKED = alarmPoint || { t: mid.t, temp: mid.temp, rh: mid.rh };

    if(dtStart) dtStart.value = '';
    if(dtEnd) dtEnd.value = '';
    clampFilterInputsToData();
    if(filterInfo) filterInfo.textContent = `(${DATA.length} puntos)`;
    updateReport(CURRENT_META, DATA);
    draw();
  }
  // Ticks are generated dynamically from the currently selected (filtered) data range.
  let MARKED = null;
  window.MARKED = null;

  // ======== Chart drawing (no external libraries) ========
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');

  let PRINT_MODE = false;

  function setCanvasSize() {
    const wrap = canvas.parentElement;
    const targetW = Math.max(640, (wrap ? wrap.clientWidth : 980) - 2);
    canvas.width = targetW;
    canvas.height = PRINT_MODE ? 660 : 560;
  }

  window.addEventListener('resize', () => {
    // keep chart crisp if the window size changes
    setCanvasSize();
    draw();
  });

  window.addEventListener('beforeprint', () => {
    PRINT_MODE = true;
    setCanvasSize();
    draw();
  });

  window.addEventListener('afterprint', () => {
    PRINT_MODE = false;
    setCanvasSize();
    draw();
  });


  function fmt2(n) {
    return (Math.round(n*100)/100).toFixed(2);
  }
  function draw() {
    // Ensure the canvas matches the available space (especially for print)
    setCanvasSize();
    const w = canvas.width, h = canvas.height;
    // Clear
    ctx.clearRect(0,0,w,h);

    if(!DATA || !DATA.length){
      // Placeholder when no CSV is loaded
      ctx.save();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.strokeRect(1,1,w-2,h-2);
      ctx.fillStyle = '#000';
      ctx.font = (PRINT_MODE ? '16px Arial' : '18px Arial');
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('Subí un CSV para ver el gráfico', w/2, h/2);
      ctx.restore();
      return;
    }


    // plot area margins (room for labels)
    const m = PRINT_MODE ? {left:62, right:70, top:54, bottom:44} : {left:70, right:72, top:52, bottom:48};

    // Ensure left margin can fit the temperature alarm labels OUTSIDE the plot area
    ctx.font = '12px Arial';
    const tempLabelW = Math.max(
      ctx.measureText('22.00°C(Hi)').width,
      ctx.measureText('0.00°C(Lo)').width
    );
    const leftNeeded = Math.ceil(tempLabelW + 18); // padding
    if (m.left < leftNeeded) m.left = leftNeeded;

    const pw = w - m.left - m.right;
    const ph = h - m.top - m.bottom;

    // ranges (match PDF)
    const yTmin = -2.0, yTmax = 31.0;
    const yHmin = 0.0, yHmax = 100.0;

    const xMin = DATA[0].t;
    const xMax = DATA[DATA.length-1].t;
    const TICKS = buildTicksFromData(DATA, TICK_COUNT);

    function xScale(t) {
      return m.left + ( (t - xMin) / Math.max(1, (xMax - xMin)) ) * pw;
    }
    function yTemp(v) {
      return m.top + (1 - (v - yTmin)/(yTmax - yTmin)) * ph;
    }
    function yHum(v) {
      return m.top + (1 - (v - yHmin)/(yHmax - yHmin)) * ph;
    }

    // background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,w,h);

    // top tick labels (time + date)
    ctx.fillStyle = '#000';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    for (let i=0;i<TICKS.length;i++) {
      const tx = xScale(TICKS[i].t);
      ctx.fillText(TICKS[i].label_time, tx, m.top-30);
      ctx.fillText(TICKS[i].label_date, tx, m.top-14);
    }

    // y ticks (left temperature)
    const yTicksTemp = [-2.0,1.3,4.6,7.9,11.2,14.5,17.8,21.1,24.4,27.7,31.0];
    const yTicksHum = [0,10,20,30,40,50,60,70,80,90,100];

    // grid lines (dotted)
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.setLineDash([2,2]);

    // vertical grid at each tick
    for (let i=0;i<TICKS.length;i++) {
      const x = xScale(TICKS[i].t);
      ctx.beginPath();
      ctx.moveTo(x, m.top);
      ctx.lineTo(x, m.top+ph);
      ctx.stroke();
    }

    // horizontal grid based on humidity ticks (every 10%)
    for (let i=0;i<yTicksHum.length;i++) {
      const y = yHum(yTicksHum[i]);
      ctx.beginPath();
      ctx.moveTo(m.left, y);
      ctx.lineTo(m.left+pw, y);
      ctx.stroke();
    }

    ctx.setLineDash([]); // reset

    // border
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.strokeRect(m.left, m.top, pw, ph);

    // left axis labels
    ctx.font = '12px Arial';
    ctx.fillStyle = '#000';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    for (let i=0;i<yTicksTemp.length;i++) {
      const v=yTicksTemp[i];
      const y=yTemp(v);
      ctx.fillText(v.toFixed(2)+'°C', m.left-10, y);
    }

    // right axis labels
    ctx.textAlign = 'left';
    for (let i=0;i<yTicksHum.length;i++) {
      const v=yTicksHum[i];
      const y=yHum(v);
      ctx.fillText(v.toFixed(2)+'%', m.left+pw+10, y);
    }

    // Alarm lines
    function hLine(y, color, dash=null) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.setLineDash(dash || []);
      ctx.beginPath();
      ctx.moveTo(m.left, y);
      ctx.lineTo(m.left+pw, y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Temp alarms
    hLine(yTemp(22.0), '#ff0000', [8,6]); // hi dashed red
    hLine(yTemp(0.0), '#0033ff', [8,6]);  // lo dashed blue

    // Humidity alarms (solid)
    hLine(yHum(70.0), '#ff0000', null);
    hLine(yHum(60.0), '#0033ff', null);

    // Alarm labels left and right edges (match PDF placement)
    ctx.font = '12px Arial';
    ctx.textBaseline = 'middle';

    // left hi/lo temp labels (avoid clipping in screen/print)
    ctx.lineJoin = 'round';
    ctx.miterLimit = 2;
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.95)';
    ctx.textAlign = 'right';

    ctx.fillStyle = '#ff0000';
    ctx.strokeText('22.00°C(Hi)', m.left-10, yTemp(22.0));
    ctx.fillText('22.00°C(Hi)', m.left-10, yTemp(22.0));

    ctx.fillStyle = '#0033ff';
    ctx.strokeText('0.00°C(Lo)', m.left-10, yTemp(0.0));
    ctx.fillText('0.00°C(Lo)', m.left-10, yTemp(0.0));

    ctx.lineWidth = 1;

    // right hi/lo humidity labels

    ctx.textAlign = 'left';
    ctx.fillStyle = '#ff0000';
    ctx.fillText('70.00%(Hi)', m.left+pw+10, yHum(70.0));
    ctx.fillStyle = '#0033ff';
    ctx.fillText('60.00%(Lo)', m.left+pw+10, yHum(60.0));

    // Clip data drawing to plot area (prevents any line escaping the box)
    ctx.save();
    ctx.beginPath();
    ctx.rect(m.left, m.top, pw, ph);
    ctx.clip();

    // Plot temperature (blue)
    ctx.strokeStyle = '#0033ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let started=false;
    for (let i=0;i<DATA.length;i++) {
      const x=xScale(DATA[i].t);
      const y=yTemp(DATA[i].temp);
      if (!started) { ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Plot humidity (green)
    ctx.strokeStyle = '#00cc00';
    ctx.lineWidth = 2;
    ctx.beginPath();
    started=false;
    for (let i=0;i<DATA.length;i++) {
      const x=xScale(DATA[i].t);
      const y=yHum(DATA[i].rh);
      if (!started) { ctx.moveTo(x,y); started=true; }
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Marked event (green inverted triangle)
    const mk = window.MARKED || MARKED;
    if (mk){
      const mx=xScale(mk.t);
      const my=yHum(mk.rh);
      ctx.fillStyle='#00cc00';
      ctx.beginPath();
      ctx.moveTo(mx, my+10);
      ctx.lineTo(mx-10, my-6);
      ctx.lineTo(mx+10, my-6);
      ctx.closePath();
      ctx.fill();
    }

    ctx.restore();

  }

  // --- UI: Export PDF (uses browser print dialog) ---
  const btnExport = document.getElementById('btnExport');
  if (btnExport) btnExport.addEventListener('click', () => window.print());

  // --- UI: CSV upload to refresh chart data ---
  const csvInput = document.getElementById('csvInput');
  const csvHint = document.getElementById('csvHint');

  function showToast(msg){
    const t=document.createElement('div');
    t.className='toast';
    t.textContent=msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(), 2200);
  }

  function parseDateTime(dateStr, timeStr){
    // Accepts formats like "21/11/25" + "13:52:22" (dd/mm/yy) or mm/dd/yy.
    const dparts = String(dateStr).replace(/\uFEFF/g,'').trim().split('/');
    if (dparts.length !== 3) return NaN;
    let a = parseInt(dparts[0],10), b = parseInt(dparts[1],10), yy = parseInt(dparts[2],10);
    if (Number.isNaN(a)||Number.isNaN(b)||Number.isNaN(yy)) return NaN;

    // If first part > 12, treat as dd/mm/yy. Otherwise default to dd/mm/yy for this device logs.
    let day=a, month=b;
    if (a <= 12 && b > 12){ day=b; month=a; }
    // year
    const year = (yy < 100) ? (2000 + yy) : yy;

    const tparts = String(timeStr).trim().split(':');
    const hh = parseInt(tparts[0]||'0',10);
    const mm = parseInt(tparts[1]||'0',10);
    const ss = parseInt(tparts[2]||'0',10);

    const dt = new Date(year, month-1, day, hh, mm, ss);
    return dt.getTime();
  }

  function parseDeviceCsv(text){
    const lines = String(text).replace(/\r/g,'').split('\n');

    const meta = { deviceId:'', currentState:'', timeZone:'' };
    // read simple "Key,Value" pairs before the data header
    for (let i=0;i<Math.min(lines.length, 30);i++){
      const raw = lines[i];
      if (!raw) continue;
      const parts = (raw.indexOf(',') !== -1) ? raw.split(',') : raw.split(';');
      if (parts.length < 2) continue;
      const key = String(parts[0]).trim();
      const val = String(parts.slice(1).join(',')).trim();
      if (!key || !val) continue;
      if (/^DeviceID$/i.test(key)) meta.deviceId = val;
      if (/^Current\s*State$/i.test(key)) meta.currentState = val;
      if (/^Time\s*Zone$/i.test(key)) meta.timeZone = val;
    }

    // Find header line like "Date,Time,℃,%RH"
    let headerIdx = -1;
    for (let i=0;i<lines.length;i++){
      const line = lines[i].trim();
      if (!line) continue;
      if (/^Date\s*,\s*Time/i.test(line) && (line.includes('RH') || line.includes('%RH'))){
        headerIdx = i;
        break;
      }
    }
    if (headerIdx === -1) return { meta, data: [] };

    const out = [];
    for (let i=headerIdx+1;i<lines.length;i++){
      const raw = lines[i].trim();
      if (!raw) continue;
      const parts = raw.split(',');
      if (parts.length < 4) continue;
      const t = parseDateTime(parts[0], parts[1]);
      const temp = parseFloat(String(parts[2]).trim());
      const rh = parseFloat(String(parts[3]).trim());
      if (!Number.isFinite(t) || !Number.isFinite(temp) || !Number.isFinite(rh)) continue;
      out.push({t, temp, rh});
    }
    out.sort((a,b)=>a.t-b.t);
    return { meta, data: out };
  }


  
  const LIMITS = { hiTemp:22.00, loTemp:0.00, hiRh:70.00, loRh:60.00 };

  function pad2(n){ return String(n).padStart(2,'0'); }

  function fmtDateTime(ms){
    const d = new Date(ms);
    const dd = pad2(d.getDate());
    const mm = pad2(d.getMonth()+1);
    const yy = pad2(d.getFullYear()%100);
    const hh = pad2(d.getHours());
    const mi = pad2(d.getMinutes());
    const ss = pad2(d.getSeconds());
    return `${dd}/${mm}/${yy} ${hh}:${mi}:${ss}`;
  }

  function fmtDuration(ms){
    let s = Math.max(0, Math.round(ms/1000));
    const d = Math.floor(s/86400); s -= d*86400;
    const h = Math.floor(s/3600);  s -= h*3600;
    const m = Math.floor(s/60);    s -= m*60;
    return `${pad2(d)}d${pad2(h)}h${pad2(m)}m${pad2(s)}s`;
  }

  function fmtTripLength(ms){
    let s = Math.max(0, Math.round(ms/1000));
    const d = Math.floor(s/86400); s -= d*86400;
    const h = Math.floor(s/3600);  s -= h*3600;
    const m = Math.floor(s/60);    s -= m*60;
    return `${d}d${h}h${m}m${s}s`;
  }


  function medianInterval(data){
    if (data.length < 3) return 0;
    const diffs = [];
    for (let i=1;i<data.length;i++){
      const dt = data[i].t - data[i-1].t;
      if (dt>0 && dt<1000*60*60*24*10) diffs.push(dt);
    }
    diffs.sort((a,b)=>a-b);
    return diffs.length ? diffs[Math.floor(diffs.length/2)] : 0;
  }

  function computeStats(data){
    let maxT=-Infinity, minT=Infinity, sumT=0;
    let maxH=-Infinity, minH=Infinity, sumH=0;
    let maxTt=0, minTt=0, maxHt=0, minHt=0;

    for (const p of data){
      sumT += p.temp; sumH += p.rh;
      if (p.temp > maxT){ maxT=p.temp; maxTt=p.t; }
      if (p.temp < minT){ minT=p.temp; minTt=p.t; }
      if (p.rh > maxH){ maxH=p.rh; maxHt=p.t; }
      if (p.rh < minH){ minH=p.rh; minHt=p.t; }
    }
    const n = data.length;
    const avgT = sumT/n;
    const avgH = sumH/n;

    const start = data[0].t;
    const stop  = data[n-1].t;
    const durMs = stop - start;

    const interval = medianInterval(data);

    return { n, maxT, minT, avgT, maxTt, minTt, maxH, minH, avgH, maxHt, minHt, start, stop, durMs, interval };
  }

  function computeAlarm(data, predicate){
    if (!data.length) return { totalMs:0, first:null };
    const interval = medianInterval(data) || 0;
    let total = 0;
    let first = null;

    for (let i=0;i<data.length;i++){
      const p = data[i];
      const next = data[i+1];
      const dt = next ? (next.t - p.t) : interval;
      if (predicate(p)){
        total += Math.max(0, dt);
        if (!first) first = p;
      }
    }
    return { totalMs: total, first };
  }

  function findFirstAlarmPoint(data){
    const a1 = computeAlarm(data, p=>p.temp > LIMITS.hiTemp).first;
    const a2 = computeAlarm(data, p=>p.rh   > LIMITS.hiRh).first;
    const a3 = computeAlarm(data, p=>p.temp < LIMITS.loTemp).first;
    const a4 = computeAlarm(data, p=>p.rh   < LIMITS.loRh).first;
    const candidates = [a1,a2,a3,a4].filter(Boolean);
    candidates.sort((x,y)=>x.t-y.t);
    return candidates[0] || null;
  }

  function setLine(id, text){
    const el = document.getElementById(id);
    if (el) el.textContent = text;
  }

  function updateAlarmTable(rows){
    const body = document.getElementById('alarmBody');
    if (!body) return;
    // keep header row (first tr)
    const trs = Array.from(body.querySelectorAll('tr'));
    trs.slice(1).forEach(tr=>tr.remove());

    for (const r of rows){
      const tr = document.createElement('tr');

      const td1 = document.createElement('td');
      td1.className = r.cls;
      td1.textContent = r.limitText;

      const td2 = document.createElement('td');
      td2.className = r.cls;
      td2.textContent = r.totalText;

      const td3 = document.createElement('td');
      td3.className = r.cls;
      td3.textContent = r.firstText;

      tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
      body.appendChild(tr);
    }
  }

  function updateReport(meta, data){
    // If no data loaded yet, reset placeholders and return
    if(!data || !data.length){
      setLine('tripNumber', (meta && (meta.deviceId || meta.DeviceID)) ? (meta.deviceId || meta.DeviceID) : '—');
      setLine('logInterval','—');
      setLine('maxTempLine','—');
      setLine('minTempLine','—');
      setLine('avgTempLine','—');
      setLine('mktLine','—');
      setLine('dataPointsLine','0');
      setLine('maxRhLine','—');
      setLine('minRhLine','—');
      setLine('avgRhLine','—');
      setLine('sumStart','—');
      setLine('sumStop','—');
      setLine('sumTripLen','—');
      updateAlarmTable([
        {cls:'r', limitText:`Sobre ${LIMITS.hiTemp.toFixed(2)}°C`, totalText:'0s', firstText:'—'},
        {cls:'r', limitText:`Sobre ${LIMITS.hiRh.toFixed(2)}%`, totalText:'0s', firstText:'—'},
        {cls:'b', limitText:`Bajo ${LIMITS.loTemp.toFixed(2)}°C`, totalText:'0s', firstText:'—'},
        {cls:'b', limitText:`Bajo ${LIMITS.loRh.toFixed(2)}%`, totalText:'0s', firstText:'—'},
      ]);
      return;
    }

    // Top: PASS/FAIL + Time Zone
    const deviceId = meta.deviceId || meta.DeviceID || '';
    if (deviceId) setLine('tripNumber', deviceId);

    if (meta.timeZone){
      const tzLine = document.getElementById('tzLine');
      if (tzLine){
        tzLine.innerHTML = `Zona horaria: <span><b>${meta.timeZone}</b></span>`;
      }
    }

    const stats = computeStats(data);

    // SUMMARY
    setLine('maxTempLine', `${stats.maxT.toFixed(2)}°C  ${fmtDateTime(stats.maxTt)}`);
    setLine('minTempLine', `${stats.minT.toFixed(2)}°C  ${fmtDateTime(stats.minTt)}`);
    setLine('avgTempLine', `${stats.avgT.toFixed(2)}°C`);
    setLine('mktLine', `${stats.avgT.toFixed(2)}°C`); // approximated
    setLine('dataPointsLine', `${stats.n}`);

    setLine('maxRhLine', `${stats.maxH.toFixed(2)}%  ${fmtDateTime(stats.maxHt)}`);
    setLine('minRhLine', `${stats.minH.toFixed(2)}%  ${fmtDateTime(stats.minHt)}`);
    setLine('avgRhLine', `${stats.avgH.toFixed(2)}%`);

    setLine('startDateLine', fmtDateTime(stats.start));
    setLine('stopDateLine', fmtDateTime(stats.stop));
    setLine('durationLine', fmtDuration(stats.durMs));


    // SUMMARY (right column) — reflect current filtered range
    setLine('sumStart', fmtDateTime(stats.start));
    setLine('sumStop', fmtDateTime(stats.stop));
    setLine('sumTripLen', fmtTripLength(stats.durMs));

    // Device config log interval
    if (stats.interval){
      const mins = Math.round(stats.interval/60000);
      const days = Math.max(1, Math.round((stats.durMs)/(86400000)));
      const li = `${mins}min/${days}d`;
      setLine('logInterval', li);
    }

    // ALARMS
    const overT = computeAlarm(data, p=>p.temp > LIMITS.hiTemp);
    const overH = computeAlarm(data, p=>p.rh   > LIMITS.hiRh);
    const underT = computeAlarm(data, p=>p.temp < LIMITS.loTemp);
    const underH = computeAlarm(data, p=>p.rh   < LIMITS.loRh);

    const fail = (overT.totalMs>0 || overH.totalMs>0 || underT.totalMs>0 || underH.totalMs>0);
    const pf = document.getElementById('passFail');
    if (pf) pf.textContent = fail ? 'FALLO' : 'APROBADO';

    updateAlarmTable([
      {
        cls:'r',
        limitText:`Sobre ${LIMITS.hiTemp.toFixed(2)}°C`,
        totalText: fmtDuration(overT.totalMs),
        firstText: overT.first ? `${fmtDateTime(overT.first.t)}  ${overT.first.temp.toFixed(2)}°C` : 'Ninguna'
      },
      {
        cls:'r',
        limitText:`Sobre ${LIMITS.hiRh.toFixed(2)}%`,
        totalText: fmtDuration(overH.totalMs),
        firstText: overH.first ? `${fmtDateTime(overH.first.t)}  ${overH.first.rh.toFixed(2)}%` : 'Ninguna'
      },
      {
        cls:'b',
        limitText:`Bajo ${LIMITS.loTemp.toFixed(2)}°C`,
        totalText: fmtDuration(underT.totalMs),
        firstText: underT.first ? `${fmtDateTime(underT.first.t)}  ${underT.first.temp.toFixed(2)}°C` : 'Ninguna'
      },
      {
        cls:'b',
        limitText:`Bajo ${LIMITS.loRh.toFixed(2)}%`,
        totalText: fmtDuration(underH.totalMs),
        firstText: underH.first ? `${fmtDateTime(underH.first.t)}  ${underH.first.rh.toFixed(2)}%` : 'Ninguna'
      }
    ]);

    // Marked event text
    const mk = window.MARKED;
    const markedEl = document.getElementById('markedText');
    if (markedEl && mk){
      markedEl.innerHTML = `${fmtDateTime(mk.t)}&nbsp;&nbsp;${mk.temp.toFixed(2)}°C&nbsp;&nbsp;${mk.rh.toFixed(2)}%`;
    }
  }

async function handleCsvFile(file){
    const text = await file.text();
    const parsed = parseDeviceCsv(text);
    const meta = parsed.meta || {};
    CURRENT_META = meta;
    const data = parsed.data || [];
    if (!data.length){
      showToast('No se detectaron datos válidos en el CSV.');
      return;
    }
    RAW_DATA = data;
    DATA = RAW_DATA.slice();

    // Choose a marked event: first alarm point if any, otherwise mid-point
    const alarmPoint = findFirstAlarmPoint(DATA);
    const mid = DATA[Math.floor(DATA.length/2)];
    window.MARKED = alarmPoint || { t: mid.t, temp: mid.temp, rh: mid.rh };

    if (csvHint) csvHint.textContent = 'CSV actual: ' + file.name;

    if (dtStart) dtStart.value = '';
    if (dtEnd) dtEnd.value = '';
    clampFilterInputsToData();
    if (filterInfo) filterInfo.textContent = `(${DATA.length} puntos)`;

    updateReport(meta, DATA);
    draw();
    showToast('CSV cargado ✓');
  }


  if (csvInput){
    csvInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      handleCsvFile(file);
      // allow re-upload same file
      e.target.value = '';
    });
  }


  if (btnApply){
    btnApply.addEventListener('click', applyFilter);
  }
  if (btnReset){
    btnReset.addEventListener('click', resetFilter);
  }


  RAW_DATA = DATA.slice();
  clampFilterInputsToData();
  if (filterInfo) filterInfo.textContent = `(${DATA.length} puntos)`;
  updateReport(CURRENT_META, DATA);
  draw();
  window.addEventListener('resize', draw);
</script>
  <script>
(async function autoLoad(){
  const url = "./data/MB121282.CSV?ts=" + Date.now();
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok){ console.warn("No pude cargar", url); return; }
  const text = await res.text();

  // Usa la misma función que procesa cuando subes un archivo
  // (en tu dashboard existe: handleCsvFile)
  await handleCsvFile(new File([text], "MB121282.CSV", {type:"text/csv"}));
})();
</script> 
</body>
</html>
